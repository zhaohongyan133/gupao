# 单例模式
单例模式可以保证内存中只存在一个对象，节省内存开销；可以避免对资源的多重占用。

它的写法有多种：懒汉式、饿汉式、注册式

# 饿汉式
优点：写法简单，不加任何锁，执行效率高

缺点：类加载时候就会初始化，无论用不用都会占用内存空间，浪费资源

# 懒汉式
优点：懒加载，调用时才会初始化，节省资源

缺点：线程不安全，要保证线程安全就需要加锁，加锁的话就会降低效率

最好的懒汉式写法是内部类单例模式，这种形式兼顾了资源浪费和synchronized性能问题

# 注册式
注册式有两种写法，一种是枚举式，一种是container形式

## 枚举式
枚举式不会被反射或序列化这种方式被破坏，推荐此种写法

## container形式
此种形式多用于需要创建的对象比较多的情况，但是线程不安全，可以通过使用场景来确定是否需要使用此形式

# 破坏单例
一般破坏单例有两种方式：反射破坏、序列化破坏

## 反射破坏单例
如下文件写的测试案例，使用发射来创建对象可以打破单例模式\src\test\java\com\gopao\singleton\innerclass\LazyInnerClassSingletonTest.java

此种方式通过在空构造器中添加代码来防止反射破坏：
    private LazyInnerClassSingletonFinal() {
        if (LazyHolder.LAZY != null) {
            throw new RuntimeException("不能创建多个实例");
        }
    }

## 序列化破坏单例
将一个对象创建好，然后将对象序列化后写入磁盘，下次使用时从磁盘中读取对象，然后通过反序列化转化为对象，
反序列化后的对象就会重新分配对象，即重新创建，如果创建的对象为单例对象，那么这就违背了单例模式的初衷，
相当于破坏了单例

解决方法：在对象中添加readResolve方法即可防止序列化破坏单例

## 内部类单例模式执行逻辑
内部类是一个单独的class，所以在初始化的时候并不会加载，只有在调用的时候才会加载